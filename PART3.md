**Write 750 words in a markdown file describing what was hard about this process, how that pain could have been avoided and what practices you are committing to perform in project2 to avoid that pain:**

The goal of Project 1 was to evaluate and reuse other people's code. However, in the process of doing this, we ran into a number of obstacles early on. This made it clear to us that we needed to establish certain practices going forward to help us and other developers who might onboard onto this project avoid the same difficulties and complete the process more quickly and effectively. One of the first issues we encountered was the project's poor error handling, or lack thereof. Knowing that the previous team was not as concerned about testing meant that they probably made other shortcuts in their code since they weren’t thinking long term.In addition to that, while executing the project, there were several unexpected crashes that were challenging to identify. If we fixed one error and then restarted the app, it would crash again with a different error which was frustrating for us, especially since none of us had worked on the app before so it’s not like we knew what the next crash might come from. In order to get the app to a running state (without manual intervention), we added error handling so that the app wouldn’t crash. Our main concern at the moment was ensuring the developer experience was made better, which in turn would also enhance the usability of the app for end users so they wouldn’t run into bugs and get the most out of what we built. Delivering concise and user-friendly error messages will help to avoid this in the future since it won’t be a guessing game anymore. Rather, it will be obvious what caused errors so bug fixes can come fast.

Due to the lack of testing that we uncovered, the project also had problems with insufficient code coverage. We began noticing that there were some unnecessary redundant files and setup files in the code coverage. This lack of accurate code coverage testing made it challenging to ensure the reliability of the application, and added another task for us to get rid of tech debt that the original team left. For example, we encountered a situation where files named 'scraper.py' and 'slash.py' were found within the src folder. At first, their inclusion in the code coverage test made us believe that these files might contain problems. Closer examination, however, revealed that they were redundant and not being used in the codebase. To prevent such confusion in the future, part of the code review process that will be enforced when a new PR is opened will have team members review each other's code for quality,test coverage, and for identifying what might become tech debt. Pair programming will be helpful for us as well, since it promotes collaborative testing and code improvement. There wasn’t much evidence the previous team did that.

The project's file structure was a bit disorganized, which made it tricky to find the specific code files we were looking for. This lack of clarity caused some difficulties in our teamwork and also slowed down our development process. The presence of duplicate "src" folders within the codebase is one such example that significantly impedes clarity and understanding. Identifying which folders are stale and which folders weren’t took valuable team time that could have been spent working on new features. A well-organized file structure is essential for collaboration and code maintenance. In Project 2, we will take the initiative to define and maintain a clear and logical file structure. This includes categorizing files into appropriate directories and establishing naming conventions that make it easy to locate and work with code files.

We mentioned previously that we saw numerous instances of duplicates in the Slash codebase, one of which being the two identical "scraper.py" files. They reside in separate subdirectories within the project folder so at first glance you would either assume that they performed different functions, or that one was a mistake. These files were essential for web scraping data to display the best deals, but the fact they both shared the same name confused us as to what their respective functionalities were when we would try to trace imports and function calls. Multiple team members contributed to the project without other team member oversight, which may be what resulted in code duplication. It was a good exercise in what might happen if an entire development team quits at a firm and a brand new team joins since all we had was stale code and stale documentation without access to the original developers. To ensure that others don't face similar issues we are going to make it a habit in Project 2 to conduct routine code reviews and cleanups. Before adding new code, we will do a thorough analysis of the current codebase to find and remove any redundant or outdated components. By doing this, we hope to improve the development process and the readability of the code. 

Another issue we faced was that the API calls would routinely fail because  they relied on private keys and tokens for authorization (for target and ebay). The team hardcoded the tokens in their code and didn’t make it obvious that they were using those keys. So as it stood it was impossible for us to retrieve data. The keys that the original team were using had probably expired (or the original team members just deleted their developer accounts). As a team we had to architect and devise a new approach to obtain the necessary data or, alternatively, seek updated credentials to revitalize the project and restore access to the API resources we required. One of our goals in Project 2 is to only use openly available APIs that don't require private keys or tokens to ensure everyone can access them. But if we come across APIs that demand such credentials, we'll provide thorough instructions on how users can create and use these keys and tokens independently. This strategy minimizes accessibility obstacles for team members and collaborators while ensuring openness and facilitating a more seamless integration of external resources.

In conclusion, Project 1 provided a valuable assessment of existing project code and the challenges we encountered during this evaluation process. Additionally, we thought of best practices that would be beneficial inorder to enhance project efficiency, benefiting both our team and future teams that might want to develop the project further in future.
